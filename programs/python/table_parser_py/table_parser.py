import argparse
import sys
import subprocess
from typing import *
from os import path
from os import remove


STRAND = Literal["+", "-"]


class ViralSeq:
    def __init__(self, name: str, evalue: float, gn_st: int, gn_end: int, bac_genome_path: str, ref_st: int, ref_end: int, ref_vir_len: int, strand: STRAND, full_cutoff: int = 100):
        self.name = name
        self. evalue = evalue
        self.gn_st = gn_st
        self.gn_end = gn_end
        self.bac_genome_path = bac_genome_path
        self.ref_st = ref_st
        self. ref_end = ref_end
        self.ref_vir_len = ref_vir_len
        self.strand = strand
        self.full_cutoff = full_cutoff
        self.len = self.__buildLen__()
        self.bac_genome_len = self.__fetch_bac_len__()
        self.percent_complete = self.__build_percent_complete__()
        self.full_len = self.__is_full_len__()
        self.is_flanked = self.__detect_flanking_atts__()

    def __buildLen__(self) -> int:
        return abs(self.gn_st - self.gn_end) + 1

    def __fetch_bac_len__(self) -> int:
        seqstat_results = do_cmd(f"esl-seqstat {self.bac_genome_path}").stdout
        for line in seqstat_results:
            if "Total # residues" in line:
                line_list = line.split()
                return line_list[3]

    def __build_percent_complete__(self) -> float:
        return float(self.len) / self.ref_vir_len

    def __is_full_len__(self):
        return (self.ref_vir_len - self.len) <= self.full_cutoff

    def __detect_flanking_atts__(self):
        #TODO: implement simple smith-waterman alignment to search for off-diagonal hits at the ends of viral genome


def parse_args(sys_args: list) -> argparse.Namespace:
    parser = argparse.ArgumentParser(sys_args, description="Accepts path to a HMM and a genome. Uses nhmmscan to produce output .dfam files, which are automatically"
                                                           " scanned by dfamscan.pl to resolve overlapping hits")
    parser.add_argument("hmm_path", type=str, help="Path to input .hmm file. The input .hmm file's directory must also contain auxiliary .hmm.h3f, "
                                              ".hmm.h3i, .hmm.h3m, and .hmm.h3p files, which are generated by hmmpress (automatically handled by hmmbuild_mult_seq.py")
    parser.add_argument("genome_path", type=str, help="Path to input genome in .fasta format")
    parser.add_argument("output_table_dir", type=str, help="Path to output directory of .dfam table files")
    parser.add_argument("--cpu", type=int, default=1, help="How many threads nhmmscan will use (i > 0)")
    parser.add_argument("--verbose", action="store_true", help="Print additional information useful for debugging")
    parser.add_argument("--force", action="store_true", help="If output file already exists, overwrite it")

    return parser.parse_args()


def do_cmd(cmd: List[str], verbose: bool) -> subprocess.CompletedProcess:
    # double check that all elements are strings
    cmd = [str(e) for e in cmd]
    if verbose:
        verbose_cmd = " ".join(cmd)
        print(f"Running command: {verbose_cmd}")

    return subprocess.run(cmd)


def _main():
    args = parse_args(sys.argv[1:])
    hmm_path = args.hmm_path
    genome_path = args.genome_path
    dfam_dir = args.output_table_dir
    cpu_count = args.cpu
    verbose = args.verbose
    force = args.force

    # check that inputs are legal
    if cpu_count < 0:
        raise ValueError("--cpu must be used with an argument greater than or equal to 0")

    if not path.isfile(hmm_path):
        raise FileNotFoundError(f"No such file: {hmm_path}")

    if not path.isfile(genome_path):
        raise FileNotFoundError(f"No such file: {genome_path}")

    if not path.isdir(dfam_dir):
        raise NotADirectoryError(f"No such folder: {dfam_dir}")


if __name__ == "__main__":
    _main()